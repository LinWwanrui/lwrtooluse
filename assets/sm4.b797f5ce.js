import{h as w}from"./index.66dbeab3.js";var T={};T.byteLength=L;T.toByteArray=E;T.fromByteArray=N;var u=[],f=[],F=typeof Uint8Array<"u"?Uint8Array:Array,A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var v=0,C=A.length;v<C;++v)u[v]=A[v],f[A.charCodeAt(v)]=v;f["-".charCodeAt(0)]=62;f["_".charCodeAt(0)]=63;function U(o){var t=o.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var e=o.indexOf("=");e===-1&&(e=t);var r=e===t?0:4-e%4;return[e,r]}function L(o){var t=U(o),e=t[0],r=t[1];return(e+r)*3/4-r}function x(o,t,e){return(t+e)*3/4-e}function E(o){var t,e=U(o),r=e[0],l=e[1],i=new F(x(o,r,l)),n=0,a=l>0?r-4:r,s;for(s=0;s<a;s+=4)t=f[o.charCodeAt(s)]<<18|f[o.charCodeAt(s+1)]<<12|f[o.charCodeAt(s+2)]<<6|f[o.charCodeAt(s+3)],i[n++]=t>>16&255,i[n++]=t>>8&255,i[n++]=t&255;return l===2&&(t=f[o.charCodeAt(s)]<<2|f[o.charCodeAt(s+1)]>>4,i[n++]=t&255),l===1&&(t=f[o.charCodeAt(s)]<<10|f[o.charCodeAt(s+1)]<<4|f[o.charCodeAt(s+2)]>>2,i[n++]=t>>8&255,i[n++]=t&255),i}function K(o){return u[o>>18&63]+u[o>>12&63]+u[o>>6&63]+u[o&63]}function R(o,t,e){for(var r,l=[],i=t;i<e;i+=3)r=(o[i]<<16&16711680)+(o[i+1]<<8&65280)+(o[i+2]&255),l.push(K(r));return l.join("")}function N(o){for(var t,e=o.length,r=e%3,l=[],i=16383,n=0,a=e-r;n<a;n+=i)l.push(R(o,n,n+i>a?a:n+i));return r===1?(t=o[e-1],l.push(u[t>>2]+u[t<<4&63]+"==")):r===2&&(t=(o[e-2]<<8)+o[e-1],l.push(u[t>>10]+u[t>>4&63]+u[t<<2&63]+"=")),l.join("")}class p{static stringToArrayBufferInUtf8(t){const e=typeof window>"u"?require("util").TextEncoder:window.TextEncoder;return new e().encode(t)}static utf8ArrayBufferToString(t){const e=typeof window>"u"?require("util").TextDecoder:window.TextDecoder;return new e("utf-8").decode(t)}static arrayBufferToBase64(t){return T.fromByteArray(t)}static base64ToArrayBuffer(t){return T.toByteArray(t)}}const c=16,B=Uint8Array.from([214,144,233,254,204,225,61,183,22,182,20,194,40,251,44,5,43,103,154,118,42,190,4,195,170,68,19,38,73,134,6,153,156,66,80,244,145,239,152,122,51,84,11,67,237,207,172,98,228,179,28,169,201,8,232,149,128,223,148,250,117,143,63,166,71,7,167,252,243,115,23,186,131,89,60,25,230,133,79,168,104,107,129,178,113,100,218,139,248,235,15,75,112,86,157,53,30,36,14,94,99,88,209,162,37,34,124,59,1,33,120,135,212,0,70,87,159,211,39,82,76,54,2,231,160,196,200,158,234,191,138,210,64,199,56,181,163,247,242,206,249,97,21,161,224,174,93,164,155,52,26,85,173,147,50,48,245,140,177,227,29,246,226,46,130,102,202,96,192,41,35,171,13,83,78,111,213,219,55,69,222,253,142,47,3,255,106,114,109,108,91,81,141,27,175,146,187,221,188,127,17,217,92,65,31,16,90,216,10,193,49,136,165,205,123,189,45,116,208,18,184,229,180,176,137,105,151,74,12,150,119,126,101,185,241,9,197,110,198,132,24,240,125,236,58,220,77,32,121,238,95,62,215,203,57,72]),b=Uint32Array.from([462357,472066609,943670861,1415275113,1886879365,2358483617,2830087869,3301692121,3773296373,4228057617,404694573,876298825,1347903077,1819507329,2291111581,2762715833,3234320085,3705924337,4177462797,337322537,808926789,1280531041,1752135293,2223739545,2695343797,3166948049,3638552301,4110090761,269950501,741554753,1213159005,1684763257]),m=Uint32Array.from([2746333894,1453994832,1736282519,2993693404]);class g{constructor(t){let e=p.stringToArrayBufferInUtf8(t.key);if(e.length!==16)throw new Error("key should be a 16 bytes string");this.key=e;let r=new Uint8Array(0);if(t.iv!==void 0&&t.iv!==null&&(r=p.stringToArrayBufferInUtf8(t.iv),r.length!==16))throw new Error("iv should be a 16 bytes string");this.iv=r,this.mode="cbc",["cbc","ecb"].indexOf(t.mode)>=0&&(this.mode=t.mode),this.cipherType="base64",["base64","text"].indexOf(t.outType)>=0&&(this.cipherType=t.outType),this.encryptRoundKeys=new Uint32Array(32),this.spawnEncryptRoundKeys(),this.decryptRoundKeys=Uint32Array.from(this.encryptRoundKeys),this.decryptRoundKeys.reverse()}doBlockCrypt(t,e){let r=new Uint32Array(36);r.set(t,0);for(let i=0;i<32;i++)r[i+4]=r[i]^this.tTransform1(r[i+1]^r[i+2]^r[i+3]^e[i]);let l=new Uint32Array(4);return l[0]=r[35],l[1]=r[34],l[2]=r[33],l[3]=r[32],l}spawnEncryptRoundKeys(){let t=new Uint32Array(4);t[0]=this.key[0]<<24|this.key[1]<<16|this.key[2]<<8|this.key[3],t[1]=this.key[4]<<24|this.key[5]<<16|this.key[6]<<8|this.key[7],t[2]=this.key[8]<<24|this.key[9]<<16|this.key[10]<<8|this.key[11],t[3]=this.key[12]<<24|this.key[13]<<16|this.key[14]<<8|this.key[15];let e=new Uint32Array(36);e[0]=t[0]^m[0],e[1]=t[1]^m[1],e[2]=t[2]^m[2],e[3]=t[3]^m[3];for(let r=0;r<32;r++)e[r+4]=e[r]^this.tTransform2(e[r+1]^e[r+2]^e[r+3]^b[r]),this.encryptRoundKeys[r]=e[r+4]}rotateLeft(t,e){return t<<e|t>>>32-e}linearTransform1(t){return t^this.rotateLeft(t,2)^this.rotateLeft(t,10)^this.rotateLeft(t,18)^this.rotateLeft(t,24)}linearTransform2(t){return t^this.rotateLeft(t,13)^this.rotateLeft(t,23)}tauTransform(t){return B[t>>>24&255]<<24|B[t>>>16&255]<<16|B[t>>>8&255]<<8|B[t&255]}tTransform1(t){let e=this.tauTransform(t);return this.linearTransform1(e)}tTransform2(t){let e=this.tauTransform(t);return this.linearTransform2(e)}padding(t){if(t===null)return null;let e=c-t.length%c,r=new Uint8Array(t.length+e);return r.set(t,0),r.fill(e,t.length),r}dePadding(t){if(t===null)return null;let e=t[t.length-1];return t.slice(0,t.length-e)}uint8ToUint32Block(t,e=0){let r=new Uint32Array(4);return r[0]=t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3],r[1]=t[e+4]<<24|t[e+5]<<16|t[e+6]<<8|t[e+7],r[2]=t[e+8]<<24|t[e+9]<<16|t[e+10]<<8|t[e+11],r[3]=t[e+12]<<24|t[e+13]<<16|t[e+14]<<8|t[e+15],r}encrypt(t){let e=p.stringToArrayBufferInUtf8(t),r=this.padding(e),l=r.length/c,i=new Uint8Array(r.length);if(this.mode==="cbc"){if(this.iv===null||this.iv.length!==16)throw new Error("iv error");let n=this.uint8ToUint32Block(this.iv);for(let a=0;a<l;a++){let s=a*c,y=this.uint8ToUint32Block(r,s);n[0]=n[0]^y[0],n[1]=n[1]^y[1],n[2]=n[2]^y[2],n[3]=n[3]^y[3];let h=this.doBlockCrypt(n,this.encryptRoundKeys);n=h;for(let d=0;d<c;d++)i[s+d]=h[parseInt(d/4)]>>(3-d)%4*8&255}}else for(let n=0;n<l;n++){let a=n*c,s=this.uint8ToUint32Block(r,a),y=this.doBlockCrypt(s,this.encryptRoundKeys);for(let h=0;h<c;h++)i[a+h]=y[parseInt(h/4)]>>(3-h)%4*8&255}return this.cipherType==="base64"?p.arrayBufferToBase64(i):p.utf8ArrayBufferToString(i)}decrypt(t){let e=new Uint8Array;this.cipherType==="base64"?e=p.base64ToArrayBuffer(t):e=p.stringToArrayBufferInUtf8(t);let r=e.length/c,l=new Uint8Array(e.length);if(this.mode==="cbc"){if(this.iv===null||this.iv.length!==16)throw new Error("iv error");let n=this.uint8ToUint32Block(this.iv);for(let a=0;a<r;a++){let s=a*c,y=this.uint8ToUint32Block(e,s),h=this.doBlockCrypt(y,this.decryptRoundKeys),d=new Uint32Array(4);d[0]=n[0]^h[0],d[1]=n[1]^h[1],d[2]=n[2]^h[2],d[3]=n[3]^h[3],n=y;for(let k=0;k<c;k++)l[s+k]=d[parseInt(k/4)]>>(3-k)%4*8&255}}else for(let n=0;n<r;n++){let a=n*c,s=this.uint8ToUint32Block(e,a),y=this.doBlockCrypt(s,this.decryptRoundKeys);for(let h=0;h<c;h++)l[a+h]=y[parseInt(h/4)]>>(3-h)%4*8&255}let i=this.dePadding(l);return p.utf8ArrayBufferToString(i)}}class S{encrypt(t,e){w.objectUnavailable(e)&&(e="HENG1AN2WEN3YIN4");let r={key:e,mode:"ecb",cipherType:"base64"};return new g(r).encrypt(t)}decrypt(t,e){w.objectUnavailable(e)&&(e="HENG1AN2WEN3YIN4");let r={key:e,mode:"ecb",cipherType:"base64"};return new g(r).decrypt(t)}}const H=new S;export{H as s};
